---
layout: post
title: "Docker와 컨테이너, 이미지"
description: >
  컨테이너 공부는 기본 중의 기본이다.
sitemap: false
hide_last_modified: true
---


0. Table of Contents
{:toc}

## 개요

머신러닝 모델링에서 점차 엔지니어링 쪽에 관심을 가지다 보니, 공부해야 할 기술이 많더라. 정말 기본 중의 기본이라고 할 수 있는 컨테이너에 대해 공부하고 있다. 좀 더 열심히 공부해서 CKA도 도전해볼 예정


## 배경 지식

운영을 위한 배포 시에 개발 환경, 그리고 다른 모든 운영 환경을 같게 만들어 주기 위해 사용하던 VM, 가상환경에서 더 진보한 형태의 "라이브러리 패키징"같은 느낌의 기술이다. 클라우드 서비스에서 컴퓨팅 자원을 사용할 때 무조건 사용하게 되기도 하고, 일반적인 process와 동일하게 취급되기 때문에(OS 위에 OS를 올리는 VM과 달리) 컴퓨터 입장에서도 굉장히 부담 없다.

일을 하면 할수록, 배우면 배울수록 이걸 모른다는 건 사칙연산을 모른다는 것만큼 기본 중의 기본으로 느껴진다.

![vm-vs-docker-containers](/assets/img/myown/vm-vs-docker-containers.png)

Kernel 모드에서 돌아가는 Docker Engine 하나로, 마치 OS를 띄운 것처럼 프로세스를 사용할 수 있게 된다.
{:.figcaption}


## 본문

리눅스 기반 OS에서는 기본적으로 Docker를 지원한다.


### Image

Docker Container 실행 시, 이미지를 기반으로 Docker를 띄운다. 이미지는 Read-only Layer로 구성되어 있으며, 각 레이어는 해당 레이어 동안 일어났던 "변경 사항"을 저장하고 있다. 마치 git 같다.

레이어는 다른 이미지끼리 공유될 수 있다. dockerhub에서 python 이미지를 가져와서 그 위에 무언가를 쌓는 이미지를 여러 개 빌드했다면, 해당 이미지들은 모두 따로 저장되는 게 아니라 "python" 이미지를 공유하고 있게 된다. 저장 공간도 효율적으로 사용하기까지 한다.

![container-filesystem](/assets/img/myown/container-filesystem.jpg)

도커의 이미지 구조, 레이어 시스템
{:.figcaption}

컨테이너가 실행되면, 그 컨테이너가 참조하는 이미지 위에 Read/Write Layer를 쌓는다. 그 위에서 "변경 사항", 즉 컨테이너 실행자의 행위가 기록된다. 이미지는 Read-only Layer로 구성되어 있기 때문에, 여러 개의 컨테이너가 하나의 이미지를 바라보고 있더라도 문제가 없다.

컨테이너가 종료되면 가장 위에 쌓여 있었던 Read/Write Layer는 사라진다. 따라서, 컨테이너 내에서 만들어진 데이터를 저장하고 싶다면 특수한 방법을 사용해서 Read/Write Layer에 있는 데이터를 나의 로컬 컴퓨터에도 저장할 수 있어야 한다. 이 방법이 [Volume](#volume)이다.


### Image 빌드 방법

Image 빌드라는 것은, 새로운 Layer를 쌓는 것과 같다.

~~~Dockerfile
FROM node:14-alpine

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

EXPOSE 80

CMD ["node", "app.js"]
~~~

`node:14-alpine`이라는 이미지(==layer의 집합) 위에, `RUN` 명령어를 통해 `npm install`이 실행된 "변경 사항"을 기록한 Layer를 새로 쌓는다.


### RUN과 CMD 명령어의 차이

`RUN`은 이미지를 쌓는 시점에 실행되는 명령어이다. 즉, 기반 이미지 위에 새로운 Layer를 쌓는 명령이며, 이미지 빌드 시(즉, Read-only Layer 집합을 만드는 것)에 한 번만 사용된다. Dockerfile 하나에서 여러 번의 `RUN` 명령을 수행할 수 있다. 반면, `CMD`는 컨테이너 실행 시 Read-only Layer들 위에 쌓이는 Read/Write Layer에서 최초로 실행되는 명령어이다. 컨테이너를 실행할 때마다, 다른 옵션이 없다면 이 명령어를 최초로 수행한다. Dockerfile 하나에 하나의 `CMD` 명령만 수행한다.


### Volume

Volume은 컨테이너가 종료된 후 모든 데이터가 휘발되는 것을 막기 위해 설정하는 것으로, 로컬 내의 경로와 컨테이너 내의 경로를 동기화한다. 컨테이너 내의 특정 경로를 볼륨으로 추가하고, 로컬 경로를 해당 볼륨의 동기화 경로로 추가하거나(Named volume/Bind Mount), 로컬 경로를 제공하지 않는(Anonymous Volume) 방식으로 로컬 저장소와 컨테이너 내 저장소를 동기화할 수 있다.


#### Anonymous Volume

Anonymous volume은, 로컬에 저장되긴 하나 해당 경로 내 데이터에 직접 액세스할 수 없다.

~~~Dockerfile
FROM node:14-alpine

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

EXPOSE 80

VOLUME ["/app/feedback"]

CMD ["node", "app.js"]
~~~

`VOLUME ["/app/feedback"]` 이 명령어는 container 내의 경로인 `app/feedback` 폴더를 volume으로 설정한다는 뜻이다. 이 명령어를 Dockerfile에 추가할 경우, 해당 Dockerfile로 빌드한 이미지를 통해 만들어지는 container는 __Anonymous Volume__ 을 생성한다. 근데 이 volume은 volume이긴 하지만, 내가 직접 볼륨 내의 데이터에 액세스할 수 없다(`docker run --rm` 옵션을 추가할 경우, container 종료 시 아예 삭제되기까지 한다). 따라서, 일반적으로 생각하는 volume의 목적, 즉 container가 종료되더라도 container 내에 생성된 데이터를 로컬에 저장하는 기능은 수행하지 못하는 것이다. __Anonymous volume__ 은 나중에, Named volume이나 Bind mount를 설정함으로써 container 내의 파일이 로컬 저장소 파일로 덮어씌워지는 걸 방지하기 위해 사용된다. 자세한 건 __Named volume__ 에서.


#### Named Volume


#### Bind Mount



## 결론



## 출처 및 참고 자료

[Udemy](https://www.udemy.com/course/docker-kubernetes-2022)
[Docker Image Layer](https://creboring.net/blog/how-docker-divide-image-layer/)